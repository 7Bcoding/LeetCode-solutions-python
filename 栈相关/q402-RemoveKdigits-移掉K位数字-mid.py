
class Solution(object):
    def removeKdigits(self, num, k):
        """
        :type num: str
        :type k: int
        :rtype: str
        """
        # 解法：贪心算法 + 单调栈
        #     对于两个相同长度的数字序列，最左边不同的数字决定了这两个数字的大小，例如，对于 A = 1axxx，
        # B = 1bxxx，如果 a > b 则 A > B。
        #     基于此，我们可以知道，若要使得剩下的数字最小，需要保证靠前的数字尽可能小。
        #   让我们从一个简单的例子开始。给定一个数字序列，例如 425，如果要求我们只删除一个数字，那么从左
        # 到右，我们有 4、2 和 5 三个选择。我们将每一个数字和它的左邻居进行比较。从 2 开始，2
        # 小于它的左邻居 4。假设我们保留数字 4，那么所有可能的组合都是以数字 4（即 42，45）开头的。相
        # 反，如果移掉 4，留下 2，我们得到的是以 2 开头的组合（即 25），这明显小于任何留下数字 4 的组合。
        # 因此我们应该移掉数字 4。如果不移掉数字 4，则之后无论移掉什么数字，都不会得到最小数。
        # -- 基于上述分析，我们可以得出「删除一个数字」的贪心策略：
        #     给定一个长度为 n 的数字序列 [D0 D1 D2 D3...Dn-1]，从左往右找到第一个位置 i (i < 0) 使得Di < Di-1，
        # 并删去Di-1；如果不存在，说明整个数字序列单调不降，删去末尾数字即可。
        # 基于此，我们可以每次对整个数字序列执行一次这个策略；删去一个字符后，剩下的 n-1 长度的数字序列就形成
        # 了新的子问题，可以继续使用同样的策略，直至删除 k 次。
        #     然而暴力的实现复杂度最差会达到 O(nk)（考虑整个数字序列是单调不降的），因此我们需要加速这个过程。
        #     考虑从左往右增量的构造最后的答案。我们可以用一个栈维护当前的答案序列，栈中的元素代表截止到当前位置，删除
        # 不超过 kk 次个数字后，所能得到的最小整数。根据之前的讨论：在使用 k 个删除次数之前，栈中的序列从栈底到栈顶单调不降。
        #     因此，对于每个数字，如果该数字小于栈顶元素，我们就不断地弹出栈顶元素，直到
        #     1. 栈为空
        #     2. 或者新的栈顶元素不大于当前数字
        #     3. 或者我们已经删除了 kk 位数字
        #     上述步骤结束后我们还需要针对一些情况做额外的处理：
        #     1. 如果我们删除了 m 个数字且 m < k，这种情况下我们需要从序列尾部删除额外的 k-m 个数字。
        #     2. 如果最终的数字序列存在前导零，我们要删去前导零。
        #     3. 如果最终数字序列为空，我们应该返回 0。
        #     最终，从栈底到栈顶的答案序列即为最小数。
        #     考虑到栈的特点是后进先出，如果通过栈实现，则需要将栈内元素依次弹出然后进行翻转才能得到最小数。为了避免翻转操作，
        # 可以使用双端队列代替栈的实现。
        #

        numstack = []

        for digit in num:
            while k and numstack and numstack[-1] > digit:
                numstack.pop()
                k -= 1
            numstack.append(digit)

        res = numstack[:-k] if k else numstack

        return "".join(res).lstrip('0') or "0"
